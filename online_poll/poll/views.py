from uuid import uuid4
from django.db.models import Count
from django.utils import timezone
from rest_framework import viewsets, status, generics
from rest_framework.decorators import action, api_view, permission_classes
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework.exceptions import ValidationError
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework_simplejwt.tokens import AccessToken
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi

from .models import Poll, PollOption, Voter, Vote
from .serializers import (
    PollSerializer, PollCreateSerializer, PollOptionSerializer,
    VoteSerializer, VoterSerializer, RegisterSerializer
)


# -------------------------
# User registration (public)
# -------------------------
class RegisterView(generics.CreateAPIView):
    serializer_class = RegisterSerializer
    permission_classes = [AllowAny]


# -------------------------
# PollViewSet
# -------------------------
class PollViewSet(viewsets.ModelViewSet):
    queryset = Poll.objects.all().order_by('-created_at')
    lookup_field = 'poll_id'

    def get_serializer_class(self):
        if self.action in ('create', 'update', 'partial_update'):
            return PollCreateSerializer
        return PollSerializer

    def perform_create(self, serializer):
        # ensure creator is request.user
        serializer.context['creator'] = self.request.user
        serializer.save()
    
    @action(detail=True, methods=["post"])
    def add_voters(self, request, pk=None):
        poll = self.get_object()
        voters = request.data.get("voters", [])

        created = []

        for v in voters:
            email = v["email"]

            voter = Voter.objects.create(email=email)

            # Already generated by the model
            temp_password = voter.temp_password
            login_token = voter.anon_id  # use anon_id as access token

            # Email the voter
            send_voter_credentials_email(
                email=email,
                temp_password=temp_password,
                login_token=login_token,
                poll=poll
            )

            created.append(VoterSerializer(voter).data)

        return Response(created, status=status.HTTP_201_CREATED)

    # -------------------- vote action --------------------
    @swagger_auto_schema(
        method='post',
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            required=['poll_option'],
            properties={
                'poll_option': openapi.Schema(type=openapi.TYPE_STRING, description='UUID of the poll option to vote for'),
                'anon_id': openapi.Schema(type=openapi.TYPE_STRING, description='Anonymous voter id (optional)'),
                'voter_token': openapi.Schema(type=openapi.TYPE_STRING, description='Voter JWT (optional)')
            }
        ),
        responses={201: VoteSerializer, 400: 'Validation errors'},
    )
    @action(detail=True, methods=['post'], url_path='vote', permission_classes=[AllowAny])
    def vote(self, request, poll_id=None):
        poll = self.get_object()
        option_id = request.data.get('poll_option')
        anon_id = request.data.get('anon_id') or str(uuid4())
        voter_token = request.data.get('voter_token')

        # resolve option
        try:
            option = poll.options.get(option_id=option_id)
        except PollOption.DoesNotExist:
            return Response({'error': 'Option does not exist for this poll.'}, status=status.HTTP_400_BAD_REQUEST)

        voter = None
        # if voter_token supplied: decode and load voter
        if voter_token:
            try:
                token = AccessToken(voter_token)
                voter_id = token.get('voter_id')
                token_poll = token.get('poll_id')
                if str(token_poll) != str(poll.poll_id):
                    return Response({'error': 'Voter token not valid for this poll.'}, status=status.HTTP_400_BAD_REQUEST)
                voter = Voter.objects.get(voter_id=voter_id, poll_id=poll.poll_id)
            except Exception:
                return Response({'error': 'Invalid voter token.'}, status=status.HTTP_400_BAD_REQUEST)

            # ensure anon_id matches voter's anon_id (best practice)
            anon_id = voter.anon_id

        # build serializer input: pass model instance for poll_option
        vote_payload = {'poll_option': option, 'anon_id': anon_id, 'voter': voter}

        serializer = VoteSerializer(data=vote_payload)
        try:
            serializer.is_valid(raise_exception=True)
            vote = serializer.save()
            return Response(VoteSerializer(vote).data, status=status.HTTP_201_CREATED)
        except ValidationError as e:
            return Response({'error': e.detail}, status=status.HTTP_400_BAD_REQUEST)

    # -------------------- results action --------------------
    @swagger_auto_schema(
        method='get',
        responses={200: PollOptionSerializer(many=True)},
    )
    @action(detail=True, methods=['get'], url_path='results', permission_classes=[AllowAny])
    def results(self, request, poll_id=None):
        poll = self.get_object()
        options = poll.options.annotate(votes_count=Count('votes')).order_by('-votes_count')
        serializer = PollOptionSerializer(options, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)


# -------------------------
# Upload voters (creator only)
# -------------------------
class VoterUploadView(generics.CreateAPIView):
    serializer_class = VoterSerializer
    permission_classes = [IsAuthenticated]

    def post(self, request, poll_id):
        emails = request.data.get('voters', [])
        created = []
        for email in emails:
            # create Voter attached to poll
            voter = Voter.objects.create(poll_id=poll_id, email=email)
            created.append({'email': email, 'temp_password': voter.temp_password, 'anon_id': voter.anon_id})
        return Response({'created': created}, status=status.HTTP_201_CREATED)


# -------------------------
# Voter login (temp credentials -> voter token)
# -------------------------
@api_view(['POST'])
@permission_classes([AllowAny])
def voter_login(request):
    email = request.data.get('email')
    temp_password = request.data.get('temp_password')
    poll_id = request.data.get('poll_id')

    try:
        voter = Voter.objects.get(email=email, poll_id=poll_id)
    except Voter.DoesNotExist:
        return Response({'error': 'Voter not found'}, status=status.HTTP_404_NOT_FOUND)

    if voter.temp_password != temp_password:
        return Response({'error': 'Invalid credentials'}, status=status.HTTP_400_BAD_REQUEST)

    # create a short-lived voter token (AccessToken) with voter_id and poll_id
    token = AccessToken()
    token['voter_id'] = str(voter.voter_id)
    token['poll_id'] = str(poll_id)
    # optionally set expiry: token.set_exp(from_now=...), but default expiry applies
    return Response({'voter_token': str(token), 'anon_id': voter.anon_id})
